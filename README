# Class note for lecture 5

GDB commands:

- layout asm: Show the assembly code.
- layout reg: Show contents of the registers.
- layout src: Show C source code.
- layout split: Show source code and assembly.
- focus asm/reg/src: Focus on a particular window, so that we can scroll that 
  window with up/down buttons.

- (Enter): Repeat the most recent command.
- info breakpoints: Show all breakpoints.
- info registers: Show all registers.
- info frames: Show the current stack frame.
- info args: Show current function arguments.

- backtrace / bt / info stack: Show all stacks.
- frame 3: switch to the 3rd frame.
- delete: delete all breakpoints.
- print statement: print the result of the statement.
  - p *argv shows the first argument
  - p *argv@2 shows the first two arguments
  - p *argv@argc shows the whole argument vector

- info locals: Show local variables.
- watch i: Get a notification whenever i changes.
- break sum_to if i==5: Break at sum_to when i is 5

- apropos [-v] tui/...: show all commands that involve tui.

Use tmux to obtain multiple windows in CLI:

- Ctrl-b c: get a nother window.
- Ctrl-b p, Ctrl-b n: navigate to the previous/next window.
- Ctrl-b %: split windows vertically.
- Ctrl-b ": split windows horizontally.
- Ctrl-b o: jump between splitted windows.

Stacks:

- The stack grows downward.
- sp points to the bottom of the stack; fp points to the top of the current
  frame.
- Leaf functions are special because they don't need to save their return
  address or any caller-saved registers.
- A function prologue is the piece of code that stores registers on the stack.
  The epilogue is where we restore those registers.

# Lab note for syscall

System call tracing
-------------------

照说明做即可。注意要沿着系统调用的路径一路添加新的项目：

- user/user.h 里跳转到用户态 ecall 声明
- user/usys.pl 里实际执行 ecall 的语句（实际上是 usys.S）
- kernel/syscall.h 里系统调用的编号
- kernel/syscall.c 里系统调用函数指针列表，以及函数声明
- kernel/sysproc.c 里系统调用函数代码

Sysinfo
-------

照说明做即可。勿忘在 kernel/defs.h 添加声明。使用 copyout 函数将内核段数据复制到用
户段。

=========================================================================

xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)). See also https://pdos.csail.mit.edu/6.828/, which
provides pointers to on-line resources for v6.

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by
Silas Boyd-Wickizer, Anton Burtsev, Dan Cross, Cody Cutler, Mike CAT,
Tej Chajed, Asami Doi, eyalz800, , Nelson Elhage, Saar Ettinger, Alice
Ferrazzi, Nathaniel Filardo, Peter Froehlich, Yakir Goaron,Shivam
Handa, Bryan Henry, jaichenhengjie, Jim Huang, Alexander Kapshuk,
Anders Kaseorg, kehao95, Wolfgang Keller, Jonathan Kimmitt, Eddie
Kohler, Austin Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay,
Hitoshi Mitake, Carmi Merimovich, Mark Morrissey, mtasm, Joel Nider,
Greg Price, Ayan Shafqat, Eldar Sehayek, Yongming Shen, Fumiya
Shigemitsu, Takahiro, Cam Tenny, tyfkda, Rafael Ubal, Warren Toomey,
Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang
Wei.

The code in the files that constitute xv6 is
Copyright 2006-2020 Frans Kaashoek, Robert Morris, and Russ Cox.

ERROR REPORTS

Please send errors and suggestions to Frans Kaashoek and Robert Morris
(kaashoek,rtm@mit.edu). The main purpose of xv6 is as a teaching
operating system for MIT's 6.S081, so we are more interested in
simplifications and clarifications than new features.

BUILDING AND RUNNING XV6

You will need a RISC-V "newlib" tool chain from
https://github.com/riscv/riscv-gnu-toolchain, and qemu compiled for
riscv64-softmmu. Once they are installed, and in your shell
search path, you can run "make qemu".
